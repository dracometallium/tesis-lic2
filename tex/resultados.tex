% vim: set spell spelllang=es syntax=tex :

\section{Metodología experimental}

Como se menciono con anterioridad, para comprobar el funcionamiento del nuevo
framework se procesaron los vídeos de resolución 352x228, 800x600 y 1280x720, en
una computadora con un procesador Intel Xeon E5-2630. Este es un procesador de 6
núcleos, cada uno de dos subprocesos simultáneos a través de la técnica de
\emph{simultaneus multithreading} y con un reloj de 2,30GHz. El equipo cuenta
ademas con 16GiB de memoria RAM. Los resultados del vídeo de resolución 352x228
píxeles no serán tratados mas adelante debido a que la carga al sistema es
reducida y no aporta información que no aporten los otros dos vídeos.

Se realizaron pruebas con cada vídeo, variando la cantidad de partes en las que
fueron divididos los cuadros de 1 a 24, y la cantidad de hilos de búsqueda entre
1 y 11. De la primera variable se tomaron todos los valores enteros dentro del
rango ya que el área del fragmento varia de forma irregular entre valores
adyacentes. De la segunda variable solo se tomaron los valores impares, ya que
el cambio de esta es mas gradual, haciendo innecesario tomar todo el conjunto
para analizar las tendencias.

En cada test se ejecuto el programa durante 13 segundos. Durante los últimos 10
segundos se contó la cantidad de cuadros procesados, y de cada uno de estos se
registro el retardo entre su creación su procesamiento. Los primeros 3 segundos
se ignoraron con el fin de permitir que la ejecución se estabilizara. Cada test
se realizo 10 veces.

Cada prueba se ejecuto dos veces, la primera buscando el mínimo de la cantidad
máxima de cuadros por segundo que soporta el sistema bajo cada configuración. En
la segunda se limito la cantidad de cuadros por segundo de cada configuración,
según lo encontrado en la prueba anterior, y se registro el tiempo de
procesamiento máximo para cada de estas.

Durante el desarrollo de la aplicación se probaron tres distintas
implementaciones. En la primera implementación, el framework ejecutaba las
distintas pilas de plugins en tareas separadas. En la segunda implementación el
framework fue modificado para que una sola tarea ejecutara todas las pilas de
plugins sobre un mismo fragmento. Para la tercera implementación se trabajo
sobre el mismo framework que la segunda, pero se unieron las pilas de búsquedas
de robots y la de búsqueda de pelota. De estas la última fue la que produjo
resultados mas satisfactorios, por lo que sera sobre los resultados de esta que
trabajaremos a continuación.

\section{Resultados}

Como se pueden ver en los siguientes gráficos, se cumplió satisfactoriamente con
el objetivo crear un sistema capas de procesar un vídeo de 800x600 píxeles a 60
cuadros por segundo, llegando casi a triplicar la cantidad de cuadros por
segundos buscados. También se logro superar esta taza en el vídeo de 1280x720
píxeles de resolución, indicando que el sistema podría ser usando bajo estas
condiciones.

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_fps.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_fps.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_bestfps.pdf}
	\caption{}

\end{figure}

En ambos gráficos surgen tres patrones no inmediatamente obvios. Por un lado, se
puede ver que existen particiones que tienen una caída en los FPS con respecto a
las particiones inmediatas. Esto se debe a que estos son números primos, lo que
lleva a que las particiones sean franjas del cuadro, incrementando el área
compartida. Otra peculiaridad que se puede notar, es que los FPS tienden a
incrementarse con el numero de particiones, aun cuando el numero de hilos de
búsqueda sea menor que este, forzando a que haya tareas que no estén ejecutando.
Esto puede ser explicado por dos factores. El primero es que al reducir el
tamaño del fragmento se aumenta la localidad espacial. El segundo es que varios
de los plugins tienen un orden de ejecución superior al lineal, por lo que
reducir el tamaño linealmente, reduce el tiempo en forma no lineal. El último
patrón que se puede observar es una caída en el rendimiento cuando la cantidad
de partes es menor la mitad que la cantidad de hilos.

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_bestfps.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxBestTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxBestTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxBestWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxBestWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}
