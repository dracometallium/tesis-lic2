% vim: set spell spelllang=es syntax=tex :

\section{Metodología experimental}

Como se menciono con anterioridad, para comprobar el funcionamiento del nuevo
framework se procesaron los vídeos de resolución 352x228, 800x600 y 1280x720, en
una computadora con un procesador Intel Xeon E5-2630. Este es un procesador de 6
núcleos, cada uno de dos subprocesos simultáneos a través de la técnica de
\emph{simultaneus multithreading} y con un reloj de 2,30GHz. El equipo cuenta
ademas con 16GiB de memoria RAM. Los resultados del vídeo de resolución 352x228
píxeles no serán tratados mas adelante debido a que la carga al sistema es
reducida y no aporta información que no aporten los otros dos vídeos.

Se realizaron pruebas con cada vídeo, variando la cantidad de partes en las que
fueron divididos los cuadros de 1 a 24, y la cantidad de hilos de búsqueda entre
1 y 11. De la primera variable se tomaron todos los valores enteros dentro del
rango ya que el área del fragmento varia de forma irregular entre valores
adyacentes. De la segunda variable solo se tomaron los valores impares, ya que
el cambio de esta es mas gradual, haciendo innecesario tomar todo el conjunto
para analizar las tendencias.

Cada prueba se ejecuto dos veces, la primera buscando el mínimo de la cantidad
máxima de cuadros por segundo que soporta el sistema bajo cada configuración. En
la segunda se limito la cantidad de cuadros por segundo de cada configuración,
según lo encontrado en la prueba anterior, y se registro el tiempo de
procesamiento máximo para cada de estas. Cada prueba consto de 10 ejecuciones
distintas de las que solo se registro el peor valor obtenido.

Dada la gran cantidad de ejecuciones se busco el tiempo mínimo necesario para
que estas fueran representativas de una ejecución prolongada. Se realizaron 3
ejecuciones con 11 hilos y 12 fragmentos, durante 11 minutos. El primer minuto
no se contabilizo con el fin de permitir que la ejecución se estabilizara.
Estas se compararon con ejecuciones bajo la misma configuración, pero ejecutando
de 10 a 20 segundos, y contabilizando solo los últimos 10. Con esta prueba se
pudo comprobar que las pruebas de 16 segundos son representativas de ejecuciones
mas largas.

Durante el desarrollo de la aplicación se probaron tres distintas
implementaciones. En la primera implementación, el framework ejecutaba las
distintas pilas de plugins en tareas separadas. En la segunda implementación el
framework fue modificado para que una sola tarea ejecutara todas las pilas de
plugins sobre un mismo fragmento. Para la tercera implementación se trabajo
sobre el mismo framework que la segunda, pero se unieron las pilas de búsquedas
de robots y la de búsqueda de pelota. De estas la última fue la que produjo
resultados mas satisfactorios, por lo que sera sobre los resultados de esta que
trabajaremos a continuación.

\section{Resultados}

Como se pueden ver en las figuras \ref{800fps} y \ref{1280fps}, se cumplió
satisfactoriamente con el objetivo crear un sistema capas de procesar un vídeo
de 800x600 píxeles a 60 cuadros por segundo, llegando casi a triplicar la
cantidad de cuadros por segundos buscados. También se logro superar esta taza en
el vídeo de 1280x720 píxeles de resolución, indicando que el sistema podría ser
usando bajo estas condiciones.

\begin{figure}[!h]

	\includegraphics[width=\textwidth]{img/800x600_fps.pdf}
	\caption{}
	\label{800fps}

\end{figure}

\begin{figure}[!h]

	\includegraphics[width=\textwidth]{img/1280x720_fps.pdf}
	\caption{}
	\label{1280fps}

\end{figure}

En las figuras \ref{800fps} y \ref{1280fps} se pueden observar dos patrones que
ocurren en ambos vídeos y cuyas causas pueden se no inmediatamente obvias. El
primero es que si los cuadros se dividen en 7, 11, 17, 19 y 23 fragmentos, se
produce una notable reducción en la cantidad de cuadros por segundo con respecto
a las divisiones adyacentes. El segundo patrón puede observar es una reducción
en la cantidad de cuadros por segundo cuando la cantidad de fragmentos es
reducida y la cantidad de hilos de búsqueda alta.

El primer patrón se debe a que el número de fragmentos es primo, lo que obliga a
dividir el cuadro en franjas, aumentando el área compartida. Para comprobar esta
hipótesis se realizaron nuevas ejecuciones del programa con el vídeo de 1280x720
pixels re resolución, 11 hilos de búsqueda y variando la cantidad de fragmentos
entre los números primos mayores a 24 y menores a 100, y los números
inmediatamente anteriores y posteriores a cada uno de ellos. En el cuadro
\ref{tabPrimos} se muestra la cantidad de cuadros procesados con un numero primo
$n$ de fragmentos, la cantidad de cuadros por segundo procesados con $n-1$
fragmentos, la cantidad procesada con $n+1$ fragmentos, y la proporción que
representan los cuadros por segundo cuando se divide el cuadro en $n$ partes en
contraste de $n-1$ y $n+1$ partes. Los valores de $n$ menores de 24 fueron
obtenidos de los resultados utilizados para la construcción de la figura
\ref{1280fps}.

\begin{table}[!h]
\begin{tabular}{l|c|c|c|c|c}
	$n$ & $fps(n)$ & $fps(n-1)$ & $fps(n+1)$ &
	$\frac{fps(n)}{fps(n-1)}$ &
	$\frac{fps(n)}{fps(n+1)}$ \\
	2 & 57 & 43 & 89 & 1.325 & 0.640 \\
	3 & 89 & 57 & 149 & 1.561 & 0.597 \\
	5 & 326 & 149 & 667 & 2.187 & 0.488 \\
	7 & 369 & 667 & 802 & 0.553 & 0.460 \\
	11 & 542 & 838 & 862 & 0.646 & 0.628 \\
	13 & 534 & 862 & 855 & 0.619 & 0.624 \\
	17 & 496 & 834 & 912 & 0.594 & 0.543 \\
	19 & 480 & 912 & 827 & 0.526 & 0.580 \\
	23 & 438 & 831 & 891 & 0.527 & 0.491 \\
	29 & 388 & 820 & 930 & 0.473 & 0.417 \\
	31 & 375 & 930 & 952 & 0.403 & 0.393 \\
	37 & 335 & 962 & 551 & 0.348 & 0.607 \\
	41 & 314 & 969 & 923 & 0.324 & 0.340 \\
	43 & 301 & 923 & 958 & 0.326 & 0.314 \\
	47 & 283 & 508 & 968 & 0.557 & 0.292 \\
	53 & 262 & 937 & 854 & 0.279 & 0.306 \\
	59 & 242 & 463 & 866 & 0.522 & 0.279 \\
	61 & 237 & 866 & 453 & 0.273 & 0.523 \\
	67 & 221 & 897 & 827 & 0.246 & 0.267 \\
	71 & 211 & 849 & 799 & 0.248 & 0.264 \\
	73 & 212 & 799 & 414 & 0.265 & 0.512 \\
	79 & 194 & 847 & 797 & 0.229 & 0.243 \\
	83 & 189 & 393 & 803 & 0.480 & 0.235 \\
	89 & 177 & 743 & 746 & 0.238 & 0.237 \\
	97 & 164 & 753 & 734 & 0.217 & 0.223 \\

\end{tabular}

\caption{Comparación de dividir el cuadro en un número primo de partes y los
	números inmediatamente anteriores y posteriores. La función $fps(x)$
	denota la cantidad de cuadros por segundo procesados al dividir el
	cuadro en $x$ partes, con 11 hilos de búsqueda.}
\label{tabPrimos}
\end{table}

Otra peculiaridad que se puede notar, es que los FPS tienden a incrementarse con
el numero de particiones, aun cuando el numero de hilos de búsqueda sea menor
que este, forzando a que haya tareas que no estén ejecutando. Esto puede ser
explicado por dos factores. El primero es que al reducir el tamaño del fragmento
se aumenta la localidad espacial. El segundo es que varios de los plugins tienen
un orden de ejecución superior al lineal, por lo que reducir el tamaño
linealmente, reduce el tiempo en forma no lineal.

El último patrón que se puede observar es una caída en el rendimiento cuando la
cantidad de partes es menor la mitad que la cantidad de hilos. Dado que no se
contaba con una herramienta para encontrar el bloque donde se estaba produciendo
el retardo\footnote{Las herramientas de \emph{profiling} para programas
secuenciales no funcionan en programas paralelos y las herramientas que soportan
programas paralelos creados con \emph{openMP} no suelen ser proveidas en los
gestores de paquetes de las distribuciones, y en algunos casos se necesita
modificar el código del programa. Se considero mas sencillo buscar
manualmente.}, se opto por una búsqueda manual. Se empezó removiendo los
plugins hasta que se encontró aquel que producía el retraso en estos casos.
Luego, sobre este, se fueron eliminando bloques de código hasta que se encontró
que la fuente es una llamada a una función de una librería externa. Examinando
el código de la función se observo que esta toma una imagen del mismo tamaño que
el fragmento del cuadro y lo pinta de un color, lo que implica escribir sobre
todos los píxeles de la imagen. Si la imagen es chica (por que el fragmento lo
es) se puede hacer mejor provecho de la memoria cache, ya que las escrituras se
realizaran sobre esta y el hilo puede continuar su ejecución mientras los
cambios se propagan a la memoria RAM. Si la imagen es muy grande, la ráfaga de
escritura es más larga, lo que lleva a que los hilos compitan por la memoria
cache. Es por esto que la cantidad de cuadros se ve empobrecida cuando la
cantidad de hilos aumenta.

Para comprobar que esta explicación es correcta se realizaron dos experimentos.
El primero consto en establecer el llamado a la función como sección critica,
impidiendo que dos hilos puedan ejecutarla al mismo tiempo. Si bien esto
introduce un retraso, para los casos donde la cantidad de particiones es
reducida, se observo una mejora, sin embargo para el resto de los casos produjo
una reducción. Es por eso que en el framework final se opto por no
establecer la función como sección critica.

El segundo experimento fue simplemente utilizar la herramienta \texttt{perf},
para comparar los accesos y fallos de cache con 1 y 10 particiones, y probando
con de 1 a 11 hilos de búsqueda. En todos los resultados se observo que la
cantidad de fallos de cache en las ejecuciones de 10 particiones siempre fue
menor que la cantidad de fallos que en la ejecución de 1 partición y misma
cantidad de hilos de búsqueda, variando desde un 37\% a un 74\%. Por otro lado,
la cantidad de accesos a cache se vio duplicada en los casos de 3 a 11 hilos.

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_bestfps.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_bestfps.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxBestTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxBestTurnArround.pdf}
	\caption{}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/800x600_maxBestWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/1280x720_maxBestWaitProb.pdf}
	\caption{Calculado usando la desigualdad de Cantelli.}

\end{figure}
