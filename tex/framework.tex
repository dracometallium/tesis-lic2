% vim: set spell spelllang=es syntax=tex :

\section{Descripción del framework}

Para aumentar el throughput del sistema se aplicaran las dos técnicas discutidas
con anterioridad. En primer lugar el sistema no estará limitado a tomar solo un
cuadro por ves. La segunda optimización consta en dividir cada cuadro para que
cada parte pueda ser procesada por un thread distinto. También debe mantenerse
que las distintas pilas de plugins ejecuten de forma independiente una de la
otra.

Para esto se propone la siguiente secuencia de procesamiento para cada ítem (un
cuadro en el caso de la solución especifica para fútbol de robots):

\begin{enumerate}

\setcounter{enumi}{-1}

\item	Antes de la ejecución el usuario establece una cantidad máxima de tareas
	en ejecución simultanea.

\item	El hilo de captura genera o captura un ítem y lo deposita en el buffer.

\item	Una tarea maestra consume el ítem mas reciente del buffer y crea una
	tarea de búsqueda para su procesamiento. Si hay mas tareas que las
	permitidas o no hay ítems en el buffer, espera.

\item	Cada tarea de búsqueda crea tantas tareas por cada una de sus pilas de
	\emph{plugins}. Mientras espera a que estas taras terminen no debe ser
	contada para el limite de tareas en ejecución.

\item	Cada tarea fracciona el ítem y crea tantas tareas como fragmentos del
	ítem se hallan creado. Esta tarea terminara tan pronto como sus tareas
	hijas terminen. Mientras espera no contribuirá al limite de tareas en
	ejecución.

\item	Las tareas procesaran cada fragmento utilizando la pila de
	\emph{plugins}. Antes de terminar eliminara el fragmento del ítem.

\item	Cuando terminan todas las tareas de las pilas de plugins, la tarea de
	búsqueda resume la ejecución para eliminar el ítem de la memoria y
	posiblemente realizar tareas conteo.

\end{enumerate}

Algo que no queda especificado en la descripción anterior, es la naturaleza de
las tareas. Por un lado, las tareas pueden comenzar su ejecución al momento de
ser creadas o pueden esperar a que la cantidad de tareas en ejecución sea menor
que el máximo establecido. La primera opción tiene como desventaja que dado que
el único control sobre la cantidad de tareas se realiza al consumir un ítem, la
cantidad de tareas en ejecución sea mayor al máximo establecido durante una
porción significativa de la duración del programa. La segunda opción solo
funcionara satisfactoriamente si se asegura que la próxima tarea a ejecutar sea
la mas antigua.

El establecer un máximo de hilos en ejecución nos permite asegurarnos de que los
hilos no compitan por la CPU y que esta se mantenga ocupada siempre que haya
tareas a realizar, simplemente estableciendo tal máximo como el números de
procesadores disponibles. Es por esto que la segunda opción es la mas deseable.

Las clases del framework básico son las siguientes:

\begin{description}

\item[Item]: Esta clase define un tipo genérico de los ítems que serán tratados
	por el sistema.

\item[RingBuffer]: Este es el buffer donde se guardan los ítems generados
	mientras esperan ser procesados. El buffer guarda solo punteros a
	objetos de la clase \emph{Item} y no tiene mecanismos de control que
	permitan acceder la estructura desde múltiples threads al mismo tiempo.
	Cuando se solicita un ítem, se devuelve el puntero al mas recientemente
	agregado o \textbf{NULL} en caso de que la estructura este vacía. Cuando
	se intenta agregar un nuevo ítem pero la estructura esta llena se coloca
	este en lugar del ítem mas viejo en la estructura y se retorna el
	puntero a este al llamador, delegándole su destrucción. La destrucción
	del ítem se delega al llamador por dos motivos. El primero es que el
	buffer desconoce el tipo real del ítem. La segunda razón es que para
	poder ser utilizado de forma segura, las llamadas a los métodos del
	buffer deben estar dentro de secciones criticas y realizar las
	eliminaciones dentro de estas podría ser muy lento.

\item[Input]: Se trata de una clase que funciona como definición de la interfaz
	de las clases que generan los ítems. Sus métodos principales son
	\emph{run} y \emph{generate}. El método \emph{generate} debe ser re
	implementado por las clases hijas para generar el tipo de ítem
	especifico del sistema. El método \emph{run} es el encargado de generar
	los ítems llamando a \emph{generate} y colocarlos en el
	\emph{RingBuffer}. Este último método puede ser redefinido si la
	aplicación así lo requiere.

\item[ItemSlicer]: Es la clase que define la interfaz de las clases encargadas
	de dividir los ítems. Se definen dos métodos. El primero es \emph{slice}
	que recibe como parámetro ítem y la cantidad de partes en la que este
	debe ser dividido y retorna un arreglo de ítems. El segundo método es
	\emph{delPart} que recibe como parámetro una de las partes creadas por
	el método \emph{slice} y la elimina.

\item[Plugin]: Esta clase define una interfaz para los plugins que realizaran
	las distintas partes del procesamiento de la imagen. Solo se define el
	método \emph{process} que tiene como único parámetro un puntero a un
	objeto de la clase \emph{Item}.

\item[PluginStack]: Esta es la clase que tomara el ítem y se encarga de
	entregarlo a cada uno de los plugins. Tiene solo dos métodos,
	\emph{addPlugin}, para agregar un plugin, y \emph{process} que tiene
	como parámetro un ítem, para procesar un ítem.

\item[ItemSwitch]: Es la clase encargada de tomar los cuadros del buffer, crear
	la partición utilizando la clase descendiente de \emph{ItemSlicer},
	crear las tareas para que las partes sean procesadas por las pilas de
	plugins y crear los hilos que ejecutaran las tareas. La cantidad hilos y
	la cantidad de partes en las cuales dividirá el ítem se definirán
	durante su creación.

\end{description}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/clasesFramework.pdf}

	\caption{Diagrama de clases Framework base.}

\end{figure}

Para adaptar el framework para utilizarlo como un sistema de visión por
computadora para el fútbol de robots se incorporaron las siguientes clases, las
cuales fueron tomadas y modificadas del sistema de visión presentado en
\cite{torres2014}:


\begin{description}

\item[Frame]: Subclase de \emph{Item}. Contiene una imagen que representa un
	cuadro y una estructura auxiliar que contiene la información necesaria
	para el funcionamiento de los plugins.

\item[CaptureFromFile]: Subclase de \emph{Input}. Es la clase encargada de crear
	el flujo de objetos \emph{Frame}, tomando cada cuadro desde un archivo
	de vídeo.

\item[FrameSlicer]: Subclase de \emph{ItemSlicer}. En este caso lo que se divide
	es la imagen del cuadro. Cada sub cuadro tendrá un solapamiento con los
	adyacente ya que se debe evitar que un robots o la pelota no este
	totalmente contenido dentro de por lo menos un sub cuadro. Para
	minimizar el área solapada las particiones se realizan de manera tal que
	se minimice el perímetro pero ocupen la mayor área posible. Para lograr
	esto se busca la partición que haga que la relación entre el alto y el
	ancho sea lo mas cercana a uno.

\item[Subclases de \emph{Plugin}]: \emph{PluginBlur},
	\emph{PluginColorConversions}, \emph{PluginColorSegmentation},
	\emph{PluginDetectBalls}, \emph{PluginFindBlobs},
	\emph{PluginFindSecondariesBlobs}, \emph{PluginMorphology} y
	\emph{PluginNetworking}.

\item[Clases auxiliares]: \emph{ball}, \emph{colorspace}, \emph{datastruct},
	\emph{homography}, \emph{marker}, \emph{pattern},
	\emph{pattern\_matching}, \emph{practicalsocket}, \emph{segmentation},
	\emph{team}, \emph{timer}.

\end{description}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/clasesFrameworkRobots.pdf}

	\caption{Diagrama de clases Framework del framework instanciado para el
	sistema de visión para el fútbol de robots.}

\end{figure}

Existen dos parámetros ajustables. El primero es la cantidad de hilos que
ejecutaran las tareas de búsqueda. El segundo parámetro es la cantidad de partes
en las cuales se dividirá el cuadro.
