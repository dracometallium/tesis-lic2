% vim: set spell spelllang=es syntax=tex :

\section{Descripción del framework}

Para aumentar el throughput del sistema se pueden aplicar cuatro enfoques distintos:

\begin{itemize}

	\item 	Dado que en un vídeo ya decodificado el procesamiento de cada
		cuadro es independiente del procesamiento de los demás, y dada
		la disponibilidad de recursos de computo, se pueden procesar
		múltiples cuadros al mismo tiempo sin que esto genere
		diferencias en la información obtenida (salvo por el orden).
		Esto permitiría aumentar la cantidad de cuadros por segundo
		obtenidos, aunque el tiempo de procesamiento de cada uno se
		mantenga igual.

	\item	Para realizar la búsqueda de los objetos, el cuadro puede ser
		dividido. Esto permitirá realizar la búsqueda en cada zona en
		paralelo. Para el correcto funcionamiento, las zonas deberán
		tener partes en común que dependerán del tamaño de los objetos,
		ya que no debe suceder que un objeto no aparezca completo en
		ninguna de las zonas. Esto permitiría reducir el tiempo de
		procesamiento de cada cuadro, ademas de que se puede sacar
		provecho de una mayor localidad espacial.

	\item	Ya que la búsqueda de cada tipo de objetos es independiente de
		la búsqueda de los demás, se pueden realizar múltiples búsquedas
		en paralelo sobre el mismo cuadro por cada tipo de objeto.

	\item	Se puede resolver el problema optimizando cada uno de los
		plugins del framework, esperando de esta manera que el tiempo de
		procesamiento de cada cuadro se reduzca lo suficiente como para
		que el sistema pueda procesar la mayoría de los cuadros a
		tiempo.

\end{itemize}

Lamentablemente este último enfoque es muy especifico de la solución para ser
aplicada en el framework. Ademas dificulta su uso como herramienta didáctica, ya
que cada plugin que se agregue o modifique deberá ser optimizado. El primer y
segundo enfoque son suficientemente generales como para ser aplicados como parte
del framework, permite agregar y modificar los plugins sin mayores dificultades,
y en el caso en el cual una solución especifica no cumpla con las condiciones
que permitan aplicar alguna de las soluciones se puede limitar el paralelismo,
ya sea no dividiendo el cuadro o procesando solo uno por vez.

Si bien el tercer enfoque es también es suficientemente general como para ser
aplicado en el framework, en las pruebas que se realizaron se comprobó que
realizar las búsquedas por cada tipo de objeto en paralelo sobre cada fragmento
tenia un efecto adverso. Por este motivo, el tercer enfoque no fue aplicado
sobre el producto final, y no sera incluido en las explicaciones siguientes. Los
detalles de los resultados que llevaron a tomar esta decisión serán detallados
mas adelante en la sección de resultados.

Conceptualmente el framework ejecuta cuatro tipos de tareas distintas que
pertenecen a uno de dos grupos que llamaremos tareas estáticas y tareas
dinámicas. Las tareas estáticas son aquellas que permanecen en ejecución desde
el inicio del programa hasta su finalización y de las que solo hay una por cada
tipo. Las tareas dinámicas son aquellas creadas para procesar un cuadro o
fragmento especifico, una ves que terminan de procesar el cuadro o fragmento
finalizan, y existen múltiples tareas del mismo tipo pero cada una asociada a un
cuadro o fragmento distinto. Las tareas del framework son:

\begin{description}

	\item[Generación de cuadros:] Es la tarea encargada de la generación o
		captura de los cuadros y colocarlos en la cola de cuadros a
		procesar. Esta es una tarea estática.

	\item[Generación de tareas dinámicas:] Esta tarea es la encargada de
		tomar un cuadro de la cola de cuadros a procesar cuando la
		cantidad de tareas dinámicas en ejecución y listas para ser
		ejecutadas sea menor que el máximo establecido al inicio de la
		aplicación, y crear una tarea de fractura para este. Esta es una
		tarea estática.

	\item[Fractura de cuadro:] Cada tarea de este tipo divide el cuadro que
		tiene asignada en una cantidad predefinida de fragmentos de
		igual tamaño. Luego crea una tarea de procesamiento de fragmento
		para cada uno de los fragmentos.

	\item[Procesamiento de fragmento:] Cada una de estas tareas toma su
		fragmento asociado y lo procesa utilizando cada una de las pilas
		de plugins.

\end{description}

\begin{figure}[!h]

	\includegraphics[width=\textwidth]{img/framework.pdf}

	\caption{Tareas principales del framework.}

	\label{tareasFramework}

\end{figure}

A medida que las tareas dinámicas son creadas se colocan en una cola de tareas.
Para su ejecución se crean una cantidad de hilos igual al numero máximo $N$ de
tareas dinámicas establecido al comienzo de la ejecución del programa. Cuando un
hilo termina de ejecutar una tarea, toma otra de la cola de tareas. En la figura
\ref{tareasFramework} se muestran un diagrama de las tareas del framework, y en
la figura \ref{hilosFramework} se muestra como las tareas son asignadas a los
hilos de ejecución.

\begin{figure}[!h]

	\includegraphics[width=\textwidth]{img/hilos.pdf}

	\caption{Asignación de tareas a los hilos de ejecución.}

	\label{hilosFramework}

\end{figure}

Si el cuadro se divide en partes sin zonas solapadas puede suceder que los
parches de un robot se encuentren en fragmentos distintos. Esto es un problema,
ya que para encontrar los robots el plugin de detección de robots debe detectar
todos los parches que lo identifican, por lo cual todos deben estar dentro del
mismo fragmento. Para asegurar esto, cada par de fragmentos adyacentes deben
compartir una zona igual al ancho de un robot. En la figura \ref{areaCompartida}
se muestran los casos donde el área compartida es menor al ancho de un robot y
donde el área compartida es del ancho de un robot.

\begin{figure}[!h]

	\centering
	\includegraphics[width=0.45\textwidth]{img/areaTooSmall.pdf}
	\includegraphics[width=0.45\textwidth]{img/areaPerfect.pdf}

	\caption{Izquierda: si el área compartida es demasiado pequeña y el
	robot se encuentra entre dos fragmentos, puede que sus parches no sean
	completamente visibles desde ninguno de ellos. Derecha: si el área
	compartida es del ancho de los robots, entonces todos los parches son
	visibles completamente desde por lo menos un fragmento.}

	\label{areaCompartida}

\end{figure}

Dado que los fragmentos comparten una área en sus bordes, la suma del área de
los fragmentos es superior al área de la imagen original. Para reducir los
píxeles a procesar, se debe reducir la zona compartida. Como la zona compartida
tiene un ancho fijo (el ancho de un robot), para encontrar el área compartida
mínima se debe minimizar el perímetro del fragmento.

Por la manera que las imágenes se representan comúnmente en una computadora y
por su simplicidad, se opto por trabajar con un teselado con rectángulos. En el
caso de estos, para minimizar su perímetro y maximizar su área, se debe procurar
que la proporción entre su ancho y altura sea lo mas cercana a uno. También,
para balancear la carga uniformemente, todos los fragmentos serán de igual
tamaño. Aquellos que se encuentren en los bordes inferior y derecho pueden que
sean mas chicos.

En la figura \ref{fragmentos} se muestran como se divide una imagen de 800x600
píxeles con un área compartida de 50 píxeles en 1, 2, 5 y 8 fragmentos. Debido a
que se divide en fragmentos rectangulares de igual tamaño, cuando el numero de
fragmentos es un numero primo, el cuadro se divide en tiras con el ancho o alto
igual que el cuadro original.

\begin{figure}[!h]

	\includegraphics[width=0.5\textwidth]{img/fragmentos1.pdf}
	\includegraphics[width=0.5\textwidth]{img/fragmentos2.pdf}
	\includegraphics[width=0.5\textwidth]{img/fragmentos5.pdf}
	\includegraphics[width=0.5\textwidth]{img/fragmentos8.pdf}
	\caption{Resultado de dividir un cuadro de 800x600 píxeles con un área
	compartida de 50 píxeles en 1(a), 2(b), 5(c) y 8(d) fragmentos.}
	\label{fragmentos}

\end{figure}

\section{Implementación del framework}

El framework fue implementado en \emph{C++} utilizando \emph{OpenMP}. La
elección del lenguaje principalmente se debe al deseo de trabajar tomando como
base el desarrollo realizado por Torres en \cite{torres2014}, en especial se
espero hacer uso de los plugins. Por su parte, el autor original del software
eligió este lenguaje debido a su eficiencia y paradigma. Dado que el sistema
debe procesar los cuadros en tiempos acotados, la eficiencia es es crucial,
mientras que el paradigma orientado a objetos permite establecer fácilmente la
interfaz de los plugins. Por otra parte, utilizar \emph{OpenMP} es una
desviación del software original.

\emph{OpenMP} es una API de bibliotecas y directivas al compilador para la
definición de paralelismo de alto nivel para sistemas de memoria compartida en
\emph{C}, \emph{C++} y \emph{Fortran}\cite{ompWeb}. La ventaja de \emph{OpenMP}
es que permite la creación de regiones paralelas, secciones criticas, tareas y
puntos de sincronización, simplemente marcando un bloque de código con unas
pocas directivas al compilador. \emph{OpenMP} ademas provee la facilidad de que
se puede establecer la cantidad de hilos que irán ejecutando las tareas, y que
el orden de la cola de espera es \emph{frist-come/first-served}. Aun así, en la
implementación final se mantiene un control del numero de tareas para no crear
mas de las que pueden ser procesadas, y no retrasar al sistema con tareas
viejas.

Las clases del framework básico son las siguientes:

\begin{description}

\item[Item:] Esta clase define un tipo genérico de los ítems que serán tratados
	por el sistema.

\item[RingBuffer:] Este es el buffer donde se guardan los ítems generados
	mientras esperan ser procesados. El buffer guarda solo punteros a
	objetos de la clase \emph{Item} y no tiene mecanismos de control que
	permitan acceder la estructura desde múltiples threads al mismo tiempo
	de forma segura. Cuando se solicita un ítem, se devuelve el puntero al
	mas antiguo o \textbf{NULL} en caso de que la estructura este vacía.
	Cuando se intenta agregar un nuevo ítem pero la estructura esta llena,
	se coloca este en espacio del ítem mas viejo en la estructura y se
	retorna el puntero de este al llamador, delegándole su destrucción. La
	destrucción del ítem se delega al llamador por dos motivos. El primero
	es que el buffer desconoce el tipo real del ítem. La segunda razón es
	que para poder ser utilizado de forma segura, las llamadas a los métodos
	del buffer deben estar dentro de secciones criticas y realizar las
	eliminaciones dentro de estas podría ser muy lento. Si el dominio así
	lo requiere, se puede cambiar el comportamiento de esta clase para que
	funcione como una pila en lugar de una cola.

\item[Input:] Se trata de una clase que funciona como definición de la interfaz
	de las clases que generan los ítems. Sus métodos principales son
	\emph{run} y \emph{generate}. El método \emph{generate} debe ser re
	implementado por las clases hijas para generar el tipo de ítem
	especifico del sistema. El método \emph{run} es el encargado de generar
	los ítems llamando a \emph{generate} y colocarlos en el
	\emph{RingBuffer}. Este último método puede ser redefinido si la
	aplicación así lo requiere.

\item[ItemSlicer:] Es la clase que define la interfaz de las clases encargadas
	de dividir los ítems. Se definen tres métodos. El primero es
	\emph{slice} que recibe como parámetro ítem y la cantidad de partes en
	la que este debe ser dividido y retorna un arreglo de ítems. El segundo
	método es \emph{resetItem} que recibe como parámetro una de las partes
	creadas por el método \emph{slice} luego de que fue procesada por una
	pila de plugins y la configura al estado para que el funcionamiento de
	la próxima pila no se vea interferido. El tercer método es
	\emph{delPart} que recibe como parámetro un fragmento de ítem y lo
	elimina.

\item[Plugin:] Esta clase define una interfaz para los plugins que realizaran
	las distintas partes del procesamiento de la imagen. Solo se define el
	método \emph{process} que tiene como único parámetro un puntero a un
	objeto de la clase \emph{Item}.

\item[PluginStack:] Esta es la clase que tomara el ítem y se encarga de
	entregarlo a cada uno de los plugins. Tiene solo dos métodos,
	\emph{addPlugin}, para agregar un plugin, y \emph{process} que tiene
	como parámetro un ítem, para procesarlo.

\item[ItemSwitch:] Esta es la clase mas compleja del framework básico, ya que es
	la que crea las múltiples tareas. La primera tarea que crea es la
	encargada de consumir los ítems del buffer y crear las tareas de
	búsqueda. Cada tarea de búsqueda divide el ítem utilizando el
	\emph{ItemSlicer} y crea una nueva tarea por cada fragmento. Por último,
	las tarea de fragmento procesara cada fragmento con todas las pilas de
	plugins de forma secuencial.

\end{description}

\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/clasesFramework.pdf}

	\caption{Diagrama de clases Framework base.}

\end{figure}

Existen dos parámetros ajustables. El primero es la cantidad de hilos que
ejecutaran las tareas de búsqueda. El segundo parámetro es la cantidad de partes
en las cuales se dividirá el cuadro.

Para adaptar el framework para utilizarlo como un sistema de visión por
computadora para el fútbol de robots se incorporaron las siguientes clases, las
cuales fueron tomadas y modificadas del sistema de visión presentado en
\cite{torres2014}:

\begin{description}

\item[Frame:] Subclase de \emph{Item}. Contiene una imagen que representa un
	cuadro y una estructura auxiliar que contiene la información necesaria
	para el funcionamiento de los plugins.

\item[CaptureFromFile:] Subclase de \emph{Input}. Es la clase encargada de crear
	el flujo de objetos \emph{Frame}, tomando cada cuadro desde un archivo
	de vídeo. También debe respetar la taza de cuadros por segundo del
	vídeo.

\item[FastCaptureFromFile:] Subclase de \emph{Input}. Muy similar a
	\emph{CaptureFromFile}, con las diferencias de que carga los cuadros a
	memoria antes de que comience el sistema a capturar los cuadros (para
	evitar los retardos de la lectura de disco y decodificación), y que
	tiene dos modos de controlar la frecuencia de la generación de los
	cuadros. Se puede adelantar la creación de cuadros si la cola de cuadros
	a procesar esta vacía, o fijar la frecuencia de su creación a un valor.
	Esta clase es útil para comprobar la capacidad máxima del sistema, ya
	que permite simular una cámara con una velocidad de captura que se
	desee, y los distintos modos permiten testear la carga máxima en cuadros
	por segundo soportada por el sistema, así como los tiempos de retardo
	bajo una cantidad de cuadros por segundo especifica.

\item[FrameSlicer:] Subclase de \emph{ItemSlicer}. En este caso lo que se divide
	es la imagen del cuadro. Cada sub cuadro tendrá un solapamiento con los
	adyacente ya que se debe evitar que un robots o la pelota no este
	totalmente contenido dentro de por lo menos un sub cuadro. Para
	minimizar el área solapada, las particiones se realizan de manera tal
	que se minimice el perímetro pero ocupen la mayor área posible. Para
	lograr esto se busca la partición que haga que la relación entre el alto
	y el ancho sea lo mas cercana a uno.

\item[Subclases de \emph{Plugin}:] \emph{PluginBlur},
	\emph{PluginColorConversions}, \emph{PluginColorSegmentation},
	\emph{PluginDetectBalls}, \emph{PluginFindBlobs},
	\emph{PluginFindSecondariesBlobs}, \emph{PluginMorphology} y
	\emph{PluginNetworking}.

\item[Clases auxiliares:] \emph{ball}, \emph{colorspace}, \emph{datastruct},
	\emph{homography}, \emph{marker}, \emph{pattern},
	\emph{pattern\_matching}, \emph{practicalsocket}, \emph{segmentation},
	\emph{team}, \emph{timer}.

\end{description}


\begin{figure}[h]

	\includegraphics[width=\textwidth]{img/clasesFrameworkRobots.pdf}

	\caption{Diagrama de clases Framework del framework instanciado para el
	sistema de visión para el fútbol de robots.}

\end{figure}

Conceptualmente, la implementación para fútbol de robots tiene dos pilas, una
para búsqueda de robots y la otra para búsqueda de la pelota. Sin embargo, ambas
pilas para la etapa de pre procesamiento de la imagen utilizan los mismos
plugins con la misma configuración, ademas, los plugins que no tienen en común
solo modifican datos propios de cada pila. Esto permite que ambas pilas puedan
ser unidas en una sola, lo que trae como ventaja que la etapa de pre
procesamiento se realice solo una ves por fragmento.
